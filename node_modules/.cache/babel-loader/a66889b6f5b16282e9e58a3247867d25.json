{"ast":null,"code":"import { Actions } from \"./decks-types\";\nimport { combineReducers } from 'redux';\nimport { Map } from 'immutable';\nexport const decks = (state = Map(), action) => {\n  switch (action.type) {\n    case Actions.ADD_DECK:\n      return state.update(action.payload.deck.uid, () => action.payload.deck);\n\n    case Actions.DELETE_DECK:\n      return state.remove(action.payload.uid);\n\n    case Actions.FETCH_DECKS_SUCCESS:\n      action.payload.decks.forEach(deck => state.set(deck.uid, deck));\n      return state;\n\n    case Actions.UPDATE_DECK:\n      return state.setIn(action.payload.deck.uid, action.payload.deck);\n\n    default:\n      return state;\n  }\n};\nexport const isFetching = (state = false, action) => {\n  switch (action.type) {\n    case Actions.FETCH_DECKS_REQUEST:\n      return true;\n\n    case Actions.FETCH_DECKS_SUCCESS:\n      return false;\n\n    case Actions.FETCH_DECKS_ERROR:\n      return false;\n\n    default:\n      return state;\n  }\n};\nexport default combineReducers({\n  isFetching: isFetching,\n  decks: decks\n});","map":{"version":3,"sources":["/Users/alexlauks/Documents/REPOS/cards-against-flora-tst/src/features/decks/decks-reducer.ts"],"names":["Actions","combineReducers","Map","decks","state","action","type","ADD_DECK","update","payload","deck","uid","DELETE_DECK","remove","FETCH_DECKS_SUCCESS","forEach","set","UPDATE_DECK","setIn","isFetching","FETCH_DECKS_REQUEST","FETCH_DECKS_ERROR"],"mappings":"AAEA,SAAsBA,OAAtB,QAA2C,eAA3C;AACA,SAASC,eAAT,QAAgC,OAAhC;AACA,SAASC,GAAT,QAAoB,WAApB;AAEA,OAAO,MAAMC,KAA6C,GAAG,CAC3DC,KAAK,GAAGF,GAAG,EADgD,EAE3DG,MAF2D,KAGrC;AACtB,UAAOA,MAAM,CAACC,IAAd;AACA,SAAKN,OAAO,CAACO,QAAb;AACC,aAAOH,KAAK,CAACI,MAAN,CAAaH,MAAM,CAACI,OAAP,CAAeC,IAAf,CAAoBC,GAAjC,EAAsC,MAAMN,MAAM,CAACI,OAAP,CAAeC,IAA3D,CAAP;;AACD,SAAKV,OAAO,CAACY,WAAb;AACC,aAAOR,KAAK,CAACS,MAAN,CAAaR,MAAM,CAACI,OAAP,CAAeE,GAA5B,CAAP;;AACC,SAAKX,OAAO,CAACc,mBAAb;AACDT,MAAAA,MAAM,CAACI,OAAP,CAAeN,KAAf,CAAqBY,OAArB,CAA6BL,IAAI,IAAIN,KAAK,CAACY,GAAN,CAAUN,IAAI,CAACC,GAAf,EAAoBD,IAApB,CAArC;AACA,aAAON,KAAP;;AACD,SAAKJ,OAAO,CAACiB,WAAb;AACC,aAAOb,KAAK,CAACc,KAAN,CAAYb,MAAM,CAACI,OAAP,CAAeC,IAAf,CAAoBC,GAAhC,EAAqCN,MAAM,CAACI,OAAP,CAAeC,IAApD,CAAP;;AACC;AAAS,aAAON,KAAP;AAVX;AAYD,CAhBM;AAkBP,OAAO,MAAMe,UAAwC,GAAG,CACvDf,KAAK,GAAG,KAD+C,EAEvDC,MAFuD,KAGnD;AACJ,UAAQA,MAAM,CAACC,IAAf;AACG,SAAKN,OAAO,CAACoB,mBAAb;AACE,aAAO,IAAP;;AACF,SAAKpB,OAAO,CAACc,mBAAb;AACD,aAAO,KAAP;;AACD,SAAKd,OAAO,CAACqB,iBAAb;AACC,aAAO,KAAP;;AACD;AACC,aAAOjB,KAAP;AARF;AAUA,CAdM;AAgBP,eAAeH,eAAe,CAAC;AAC9BkB,EAAAA,UAAU,EAAEA,UADkB;AAE9BhB,EAAAA,KAAK,EAAEA;AAFuB,CAAD,CAA9B","sourcesContent":["\nimport { Reducer } from 'typesafe-actions';\nimport { ActionTypes, Actions, Deck } from \"./decks-types\";\nimport { combineReducers } from 'redux';\nimport { Map } from 'immutable';\n\nexport const decks:Reducer<Map<string, Deck>, ActionTypes> = (\n  state = Map(),\n  action: ActionTypes,\n): Map<string, Deck> => {\n  switch(action.type){\n\t\tcase Actions.ADD_DECK:\n\t\t\treturn state.update(action.payload.deck.uid, () => action.payload.deck);\n\t\tcase Actions.DELETE_DECK:\n\t\t\treturn state.remove(action.payload.uid);\n    case Actions.FETCH_DECKS_SUCCESS:\n\t\t\taction.payload.decks.forEach(deck => state.set(deck.uid, deck));\n\t\t\treturn state;\n\t\tcase Actions.UPDATE_DECK:\n\t\t\treturn state.setIn(action.payload.deck.uid, action.payload.deck);\n    default: return state;\n  }\n};\n\nexport const isFetching:Reducer<boolean, ActionTypes> = (\n\tstate = false,\n\taction: ActionTypes,\n) => {\n\tswitch (action.type) {\n    case Actions.FETCH_DECKS_REQUEST:\n      return true;\n    case Actions.FETCH_DECKS_SUCCESS:\n\t\t\treturn false;\n\t\tcase Actions.FETCH_DECKS_ERROR:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nexport default combineReducers({\n\tisFetching: isFetching,\n\tdecks: decks,\n});"]},"metadata":{},"sourceType":"module"}