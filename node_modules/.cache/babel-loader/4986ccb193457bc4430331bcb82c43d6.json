{"ast":null,"code":"import { all, call, fork, put, takeEvery } from 'redux-saga/effects';\nimport * as actions from './cards-actions';\nimport { Actions as ActionTypes, CardTypes } from './cards-types';\nconst cardsFake = [{\n  uid: '1',\n  type: CardTypes.Fresh,\n  fillingTxt: 'FreshCard 1'\n}, {\n  uid: '2',\n  type: CardTypes.Fresh,\n  fillingTxt: 'FreshCard 2'\n}, {\n  uid: '3',\n  type: CardTypes.Fresh,\n  fillingTxt: 'FreshCard 3'\n}, {\n  uid: '4',\n  type: CardTypes.Fresh,\n  fillingTxt: 'FreshCard 4'\n}, {\n  uid: '5',\n  type: CardTypes.Fresh,\n  fillingTxt: 'FreshCard 5'\n}, {\n  uid: '1',\n  type: CardTypes.Rotten,\n  declarationTxt: 'Rotten 1'\n}, {\n  uid: '2',\n  type: CardTypes.Rotten,\n  declarationTxt: 'Rotten 2'\n}];\n\nconst fakeFetch = () => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    // resolve({\n    //   cards: cardsFake,\n    // });\n    reject('ERROR FETCHING CARDS');\n  }, 3000);\n});\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fakeFetch);\n\n    if (res.error) {\n      yield put(actions.fetchCardsError(res.error));\n    } else {\n      yield put(actions.fetchCardsSuccess(res.cards));\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchCardsError(err.stack));\n    } else {\n      yield put(actions.fetchCardsError('An unknown error occured.'));\n    }\n  }\n} // This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\n\n\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_CARDS_REQUEST, handleFetch);\n} // Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\n\n\nexport function* CardsSaga() {\n  yield all([fork(watchFetchRequest)]);\n}","map":{"version":3,"sources":["/Users/alexlauks/Documents/REPOS/cards-against-flora-tst/src/features/cards/cards-sagas.ts"],"names":["all","call","fork","put","takeEvery","actions","Actions","ActionTypes","CardTypes","cardsFake","uid","type","Fresh","fillingTxt","Rotten","declarationTxt","fakeFetch","Promise","resolve","reject","setTimeout","handleFetch","res","error","fetchCardsError","fetchCardsSuccess","cards","err","Error","stack","watchFetchRequest","FETCH_CARDS_REQUEST","CardsSaga"],"mappings":"AAAA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+BC,SAA/B,QAAgD,oBAAhD;AACA,OAAO,KAAKC,OAAZ,MAAyB,iBAAzB;AACA,SAASC,OAAO,IAAIC,WAApB,EAAuCC,SAAvC,QAAwD,eAAxD;AAEA,MAAMC,SAAgB,GAAG,CACvB;AAAEC,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACI,KAA5B;AAAmCC,EAAAA,UAAU,EAAE;AAA/C,CADuB,EAEvB;AAAEH,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACI,KAA5B;AAAmCC,EAAAA,UAAU,EAAE;AAA/C,CAFuB,EAGvB;AAAEH,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACI,KAA5B;AAAmCC,EAAAA,UAAU,EAAE;AAA/C,CAHuB,EAIvB;AAAEH,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACI,KAA5B;AAAmCC,EAAAA,UAAU,EAAE;AAA/C,CAJuB,EAKvB;AAAEH,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACI,KAA5B;AAAmCC,EAAAA,UAAU,EAAE;AAA/C,CALuB,EAMvB;AAAEH,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACM,MAA5B;AAAoCC,EAAAA,cAAc,EAAE;AAApD,CANuB,EAOvB;AAAEL,EAAAA,GAAG,EAAE,GAAP;AAAYC,EAAAA,IAAI,EAAEH,SAAS,CAACM,MAA5B;AAAoCC,EAAAA,cAAc,EAAE;AAApD,CAPuB,CAAzB;;AAUA,MAAMC,SAAS,GAAG,MAAmB,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpEC,EAAAA,UAAU,CAAC,MAAM;AACf;AACA;AACA;AACAD,IAAAA,MAAM,CAAC,sBAAD,CAAN;AACD,GALS,EAKP,IALO,CAAV;AAMD,CAPoC,CAArC;;AASA,UAAUE,WAAV,GAAwB;AACtB,MAAI;AACF,UAAMC,GAAG,GAAG,MAAMrB,IAAI,CAACe,SAAD,CAAtB;;AAEA,QAAIM,GAAG,CAACC,KAAR,EAAe;AACb,YAAMpB,GAAG,CAACE,OAAO,CAACmB,eAAR,CAAwBF,GAAG,CAACC,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAMpB,GAAG,CAACE,OAAO,CAACoB,iBAAR,CAA0BH,GAAG,CAACI,KAA9B,CAAD,CAAT;AACD;AACF,GARD,CAQE,OAAOC,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxB,YAAMzB,GAAG,CAACE,OAAO,CAACmB,eAAR,CAAwBG,GAAG,CAACE,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAM1B,GAAG,CAACE,OAAO,CAACmB,eAAR,CAAwB,2BAAxB,CAAD,CAAT;AACD;AACF;AACF,C,CAED;AACA;;;AACA,UAAUM,iBAAV,GAA8B;AAC5B,QAAM1B,SAAS,CAACG,WAAW,CAACwB,mBAAb,EAAkCV,WAAlC,CAAf;AACD,C,CAED;AACA;;;AACA,OAAO,UAAUW,SAAV,GAAsB;AAC3B,QAAMhC,GAAG,CAAC,CAACE,IAAI,CAAC4B,iBAAD,CAAL,CAAD,CAAT;AACD","sourcesContent":["import { all, call, fork, put, takeEvery } from 'redux-saga/effects'\nimport * as actions from './cards-actions';\nimport { Actions as ActionTypes, Card, CardTypes } from './cards-types';\n\nconst cardsFake:Card[] = [\n  { uid: '1', type: CardTypes.Fresh, fillingTxt: 'FreshCard 1'},\n  { uid: '2', type: CardTypes.Fresh, fillingTxt: 'FreshCard 2'},\n  { uid: '3', type: CardTypes.Fresh, fillingTxt: 'FreshCard 3'},\n  { uid: '4', type: CardTypes.Fresh, fillingTxt: 'FreshCard 4'},\n  { uid: '5', type: CardTypes.Fresh, fillingTxt: 'FreshCard 5'},\n  { uid: '1', type: CardTypes.Rotten, declarationTxt: 'Rotten 1'},\n  { uid: '2', type: CardTypes.Rotten, declarationTxt: 'Rotten 2'},\n];\n\nconst fakeFetch = ():Promise<any> => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    // resolve({\n    //   cards: cardsFake,\n    // });\n    reject('ERROR FETCHING CARDS')\n  }, 3000);\n});\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fakeFetch);\n\n    if (res.error) {\n      yield put(actions.fetchCardsError(res.error))\n    } else {\n      yield put(actions.fetchCardsSuccess(res.cards))\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchCardsError(err.stack!))\n    } else {\n      yield put(actions.fetchCardsError('An unknown error occured.'))\n    }\n  }\n}\n\n// This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_CARDS_REQUEST, handleFetch);\n}\n\n// Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\nexport function* CardsSaga() {\n  yield all([fork(watchFetchRequest)])\n}"]},"metadata":{},"sourceType":"module"}