{"ast":null,"code":"import { all, call, fork, put, takeEvery } from 'redux-saga/effects';\nimport * as actions from './decks-actions';\nimport { API_ROOT_URL } from '../../store/utils';\nimport { Actions as ActionTypes } from './decks-types';\nconst DECKS_ENDPOINT = \"\".concat(process.env.REACT_APP_API_ENDPOINT, \"/decks\") || \"\".concat(API_ROOT_URL, \"/decks\");\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fetch, DECKS_ENDPOINT);\n\n    if (res.error) {\n      yield put(actions.fetchDecskError(res.error));\n    } else {\n      yield put(actions.fetchDecksSuccess(res.decks));\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchDecskError(err.stack));\n    } else {\n      yield put(actions.fetchDecskError('An unknown error occured.'));\n    }\n  }\n} // This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\n\n\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_DECKS_REQUEST, handleFetch);\n} // Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\n\n\nexport function* DecksSaga() {\n  yield all([fork(watchFetchRequest)]);\n}","map":{"version":3,"sources":["/Users/alexlauks/Documents/REPOS/cards-against-flora-tst/src/features/decks/decks-sagas.ts"],"names":["all","call","fork","put","takeEvery","actions","API_ROOT_URL","Actions","ActionTypes","DECKS_ENDPOINT","process","env","REACT_APP_API_ENDPOINT","handleFetch","res","fetch","error","fetchDecskError","fetchDecksSuccess","decks","err","Error","stack","watchFetchRequest","FETCH_DECKS_REQUEST","DecksSaga"],"mappings":"AAAA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+BC,SAA/B,QAAgD,oBAAhD;AACA,OAAO,KAAKC,OAAZ,MAAyB,iBAAzB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,SAASC,OAAO,IAAIC,WAApB,QAAuC,eAAvC;AAEA,MAAMC,cAAc,GAClB,UAAGC,OAAO,CAACC,GAAR,CAAYC,sBAAf,yBACGN,YADH,WADF;;AAIA,UAAUO,WAAV,GAAwB;AACtB,MAAI;AACF,UAAMC,GAAG,GAAG,MAAMb,IAAI,CAACc,KAAD,EAAQN,cAAR,CAAtB;;AAEA,QAAIK,GAAG,CAACE,KAAR,EAAe;AACb,YAAMb,GAAG,CAACE,OAAO,CAACY,eAAR,CAAwBH,GAAG,CAACE,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAMb,GAAG,CAACE,OAAO,CAACa,iBAAR,CAA0BJ,GAAG,CAACK,KAA9B,CAAD,CAAT;AACD;AACF,GARD,CAQE,OAAOC,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxB,YAAMlB,GAAG,CAACE,OAAO,CAACY,eAAR,CAAwBG,GAAG,CAACE,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAMnB,GAAG,CAACE,OAAO,CAACY,eAAR,CAAwB,2BAAxB,CAAD,CAAT;AACD;AACF;AACF,C,CAED;AACA;;;AACA,UAAUM,iBAAV,GAA8B;AAC5B,QAAMnB,SAAS,CAACI,WAAW,CAACgB,mBAAb,EAAkCX,WAAlC,CAAf;AACD,C,CAED;AACA;;;AACA,OAAO,UAAUY,SAAV,GAAsB;AAC3B,QAAMzB,GAAG,CAAC,CAACE,IAAI,CAACqB,iBAAD,CAAL,CAAD,CAAT;AACD","sourcesContent":["import { all, call, fork, put, takeEvery } from 'redux-saga/effects'\nimport * as actions from './decks-actions';\nimport { API_ROOT_URL } from '../../store/utils';\nimport { Actions as ActionTypes } from './decks-types';\n\nconst DECKS_ENDPOINT = \n  `${process.env.REACT_APP_API_ENDPOINT}/decks` ||\n  `${API_ROOT_URL}/decks`;\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fetch, DECKS_ENDPOINT);\n\n    if (res.error) {\n      yield put(actions.fetchDecskError(res.error))\n    } else {\n      yield put(actions.fetchDecksSuccess(res.decks))\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchDecskError(err.stack!))\n    } else {\n      yield put(actions.fetchDecskError('An unknown error occured.'))\n    }\n  }\n}\n\n// This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_DECKS_REQUEST, handleFetch);\n}\n\n// Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\nexport function* DecksSaga() {\n  yield all([fork(watchFetchRequest)])\n}"]},"metadata":{},"sourceType":"module"}