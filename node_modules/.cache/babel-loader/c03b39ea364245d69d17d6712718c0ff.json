{"ast":null,"code":"import { all, call, fork, put, takeEvery } from 'redux-saga/effects';\nimport * as actions from './decks-actions';\nimport { API_ROOT_URL } from '../../store/utils';\nimport { Actions as ActionTypes } from './decks-types';\nconst DECKS_ENDPOINT = \"\".concat(process.env.REACT_APP_API_ENDPOINT, \"/decks\") || \"\".concat(API_ROOT_URL, \"/decks\");\nconst fakeDecks = [{\n  uid: '001',\n  displayName: 'Sample Deck 1',\n  rottenCards: [],\n  freshCards: []\n}, {\n  uid: '002',\n  displayName: 'Sample Deck 2',\n  rottenCards: [],\n  freshCards: []\n}, {\n  uid: '003',\n  displayName: 'Sample Deck 3',\n  rottenCards: [],\n  freshCards: []\n}, {\n  uid: '004',\n  displayName: 'Sample Deck 4',\n  rottenCards: [],\n  freshCards: []\n}];\n\nconst fakeFetch = () => new Promise(resolve => {\n  setTimeout(() => {\n    resolve({\n      decks: fakeDecks\n    });\n  }, 3000);\n});\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fakeFetch);\n\n    if (res.error) {\n      yield put(actions.fetchDecskError(res.error));\n    } else {\n      yield put(actions.fetchDecksSuccess(res.decks));\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchDecskError(err.stack));\n    } else {\n      yield put(actions.fetchDecskError('An unknown error occured.'));\n    }\n  }\n} // This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\n\n\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_DECKS_REQUEST, handleFetch);\n} // Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\n\n\nexport function* DecksSaga() {\n  yield all([fork(watchFetchRequest)]);\n}","map":{"version":3,"sources":["/Users/alexlauks/Documents/REPOS/cards-against-flora-tst/src/features/decks/decks-sagas.ts"],"names":["all","call","fork","put","takeEvery","actions","API_ROOT_URL","Actions","ActionTypes","DECKS_ENDPOINT","process","env","REACT_APP_API_ENDPOINT","fakeDecks","uid","displayName","rottenCards","freshCards","fakeFetch","Promise","resolve","setTimeout","decks","handleFetch","res","error","fetchDecskError","fetchDecksSuccess","err","Error","stack","watchFetchRequest","FETCH_DECKS_REQUEST","DecksSaga"],"mappings":"AAAA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+BC,SAA/B,QAAgD,oBAAhD;AACA,OAAO,KAAKC,OAAZ,MAAyB,iBAAzB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,SAASC,OAAO,IAAIC,WAApB,QAA6C,eAA7C;AAEA,MAAMC,cAAc,GAClB,UAAGC,OAAO,CAACC,GAAR,CAAYC,sBAAf,yBACGN,YADH,WADF;AAIA,MAAMO,SAAS,GAAG,CAChB;AAAEC,EAAAA,GAAG,EAAE,KAAP;AAAcC,EAAAA,WAAW,EAAE,eAA3B;AAA4CC,EAAAA,WAAW,EAAE,EAAzD;AAA6DC,EAAAA,UAAU,EAAE;AAAzE,CADgB,EAEhB;AAAEH,EAAAA,GAAG,EAAE,KAAP;AAAcC,EAAAA,WAAW,EAAE,eAA3B;AAA4CC,EAAAA,WAAW,EAAE,EAAzD;AAA6DC,EAAAA,UAAU,EAAE;AAAzE,CAFgB,EAGhB;AAAEH,EAAAA,GAAG,EAAE,KAAP;AAAcC,EAAAA,WAAW,EAAE,eAA3B;AAA4CC,EAAAA,WAAW,EAAE,EAAzD;AAA6DC,EAAAA,UAAU,EAAE;AAAzE,CAHgB,EAIhB;AAAEH,EAAAA,GAAG,EAAE,KAAP;AAAcC,EAAAA,WAAW,EAAE,eAA3B;AAA4CC,EAAAA,WAAW,EAAE,EAAzD;AAA6DC,EAAAA,UAAU,EAAE;AAAzE,CAJgB,CAAlB;;AAOA,MAAMC,SAAS,GAAG,MAAmB,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC1DC,EAAAA,UAAU,CAAC,MAAM;AACfD,IAAAA,OAAO,CAAC;AACNE,MAAAA,KAAK,EAAET;AADD,KAAD,CAAP;AAGD,GAJS,EAIP,IAJO,CAAV;AAKD,CANkC,CAArC;;AAQA,UAAUU,WAAV,GAAwB;AACtB,MAAI;AACF,UAAMC,GAAG,GAAG,MAAMvB,IAAI,CAACiB,SAAD,CAAtB;;AAEA,QAAIM,GAAG,CAACC,KAAR,EAAe;AACb,YAAMtB,GAAG,CAACE,OAAO,CAACqB,eAAR,CAAwBF,GAAG,CAACC,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAMtB,GAAG,CAACE,OAAO,CAACsB,iBAAR,CAA0BH,GAAG,CAACF,KAA9B,CAAD,CAAT;AACD;AACF,GARD,CAQE,OAAOM,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxB,YAAM1B,GAAG,CAACE,OAAO,CAACqB,eAAR,CAAwBE,GAAG,CAACE,KAA5B,CAAD,CAAT;AACD,KAFD,MAEO;AACL,YAAM3B,GAAG,CAACE,OAAO,CAACqB,eAAR,CAAwB,2BAAxB,CAAD,CAAT;AACD;AACF;AACF,C,CAED;AACA;;;AACA,UAAUK,iBAAV,GAA8B;AAC5B,QAAM3B,SAAS,CAACI,WAAW,CAACwB,mBAAb,EAAkCT,WAAlC,CAAf;AACD,C,CAED;AACA;;;AACA,OAAO,UAAUU,SAAV,GAAsB;AAC3B,QAAMjC,GAAG,CAAC,CAACE,IAAI,CAAC6B,iBAAD,CAAL,CAAD,CAAT;AACD","sourcesContent":["import { all, call, fork, put, takeEvery } from 'redux-saga/effects'\nimport * as actions from './decks-actions';\nimport { API_ROOT_URL } from '../../store/utils';\nimport { Actions as ActionTypes, Deck } from './decks-types';\n\nconst DECKS_ENDPOINT = \n  `${process.env.REACT_APP_API_ENDPOINT}/decks` ||\n  `${API_ROOT_URL}/decks`;\n\nconst fakeDecks = [\n  { uid: '001', displayName: 'Sample Deck 1', rottenCards: [], freshCards: []},\n  { uid: '002', displayName: 'Sample Deck 2', rottenCards: [], freshCards: []},\n  { uid: '003', displayName: 'Sample Deck 3', rottenCards: [], freshCards: []},\n  { uid: '004', displayName: 'Sample Deck 4', rottenCards: [], freshCards: []},\n];\n\nconst fakeFetch = ():Promise<any> => new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        decks: fakeDecks,\n      });\n    }, 3000);\n  });\n\nfunction* handleFetch() {\n  try {\n    const res = yield call(fakeFetch);\n\n    if (res.error) {\n      yield put(actions.fetchDecskError(res.error))\n    } else {\n      yield put(actions.fetchDecksSuccess(res.decks))\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      yield put(actions.fetchDecskError(err.stack!))\n    } else {\n      yield put(actions.fetchDecskError('An unknown error occured.'))\n    }\n  }\n}\n\n// This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\nfunction* watchFetchRequest() {\n  yield takeEvery(ActionTypes.FETCH_DECKS_REQUEST, handleFetch);\n}\n\n// Export our root saga.\n// We can also use `fork()` here to split our saga into multiple watchers.\nexport function* DecksSaga() {\n  yield all([fork(watchFetchRequest)])\n}"]},"metadata":{},"sourceType":"module"}